/*
Copyright (c) 2012, Bruno Turcksin.

This file is part of Janus.

Janu is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
he Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Janus is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Janus.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef _CROSS_SECTIONS_HH_
#define _CROSS_SECTIONS_HH_

#include <cmath>
#include <fstream>
#include <string>
#include <vector>
#include "EXCEPTION.hh"
#include "PARAMETERS.hh"

using namespace std;

typedef vector<unsigned int> ui_vector;
typedef vector<double> d_vector;

/**
 * Read and the store all the cross sections. Cross sections generated by the 
 * modified ASCII CEPXS are read in the following order: number of groups of 
 * gammas, number of groups of electrons, number of groups of positrons, 
 * number of materials, L max, loop over the materials: read the total cross
 * sections, the energy deposition cross sections, the scattering cross
 * sections. Cross sections generated manually are read in the following
 * order: number of groups, number of materials, L max, flag if the energy cross 
 * sections are present, loop over the materials: read the total cross sections, 
 * the energy deposition cross sections if present, the scattering cross sections. 
 * Fokker-Planck cross sections \f$\left(\frac{\alpha}{2} (L(L+1)-l(l+1))\right)\f$ 
 * can be also be generated but only for one group. First the number of materials 
 * is read, then the total cross sections and finally alpha.
 */
class CROSS_SECTIONS
{
  public :
    CROSS_SECTIONS(string* cross_section_inputfile);

    /// Read and reorder the cross sections generated by CEPXS.
    void Read_cepxs_cross_sections(const unsigned int n_mat,
        const PERMUTATION_TYPE permutation_type);

    /// Read the cross sections generated manually.
    void Read_regular_cross_sections(const unsigned int n_mat,
        const PERMUTATION_TYPE permutation_typem,const bool energy_deposition);

    /// Build the Fokker-Planck cross sections.
    void Build_fokker_planck_xs(const unsigned int n_mat);

    /// Compute the cross sections needed by the angular multigrid and/or
    /// apply if necessary the transport correction.
    void Apply_ang_lvls_and_tc(const bool ang_lvls,const bool tc,const bool optimal,
        const unsigned int n_mat,const unsigned int sn);

    /// Return the flag on the existence of energy deposition cross sections.
    bool Sigma_e_exist() const;

    /// Return #L_max.
    unsigned int Get_L_max() const;

    /// Return the number of groups.
    unsigned int Get_n_groups() const;

    /// Return the number of supergroups. When CEPXS is used, the groups are
    /// aggregates in supergroups which are solved independently.
    unsigned int Get_n_supergroups() const;

    /// Return the number of groups in a supergroup.
    unsigned int Get_n_grps_in_supergrp() const;

    /// Return the number of "angular levels" (DSA counts as an angular level).
    unsigned int Get_n_levels() const;

    /// Return the energy deposition cross sections for the material i.
    d_vector Get_sigma_e(unsigned int i) const;

    /// Return the total cross sections for the material i.
    vector<d_vector> Get_sigma_t(unsigned int i) const;

    /// Return the scattering cross sections for the material i.
    vector<vector<vector<d_vector> > > Get_sigma_s(unsigned int i) const;

  private :
    /// Create the angular multigrid cross sections.
    void Apply_angular_levels(const unsigned int n_mat,const unsigned int sn);

    /// Apply the "standard" extended transport correction of the "optimal"
    /// extended transport correction.
    void Apply_transport_correction(const unsigned int i_mat,const unsigned int g,
        const unsigned int lvl,double correction);

    /// Apply the permutation on the cross sections.
    void Apply_cross_section_permutation(const PERMUTATION_TYPE permutation_type,
        const unsigned int n_mat);

    /// Return the greatest commun divisor between n_a and n_b.
    unsigned int Compute_gcd(unsigned int n_a,unsigned int n_b);
                
    /// Reorder #sigma_s given a permutation matrix. 
    void Matrix_multiplication(const unsigned int n_mat,
        vector<d_vector> const &permutation_m);
                                                    
    /// Reorder #sigma_t and #sigma_e given a permutation vector.
    void Vector_permutation(const unsigned int n_mat, ui_vector const &permutation_v);

    /// Create the permutation matrix and the permutation vector when the
    /// energy groups are linear.
    void Create_linear_permutation(vector<d_vector> &permutation_m,
        ui_vector &permutation,bool &identity);

    /// Create the permutation matrix and the permutation vector when the
    /// energy groups are logarithmic.
    void Create_log_permutation(vector<d_vector> &permutation_m,
        ui_vector &permutation_b);

    /// Flag for #sigma_e
    bool sigma_e_flag;
    /// L_max.
    unsigned int L_max;
    /// Number of photon (gamma) groups.
    unsigned int n_g_groups;
    /// Number of electron groups.
    unsigned int n_e_groups;
    /// Number of positron groups.
    unsigned int n_p_groups;
    /// Number of groups.
    unsigned int n_groups;
    /// Number of supergroups.
    unsigned int n_supergroups;
    /// Number of levels of the angular multigrid.
    unsigned int n_levels;
    /// Pointer to the name of the input file containing the cross sections of
    string* cross_section_filename;
    /// Total cross section.
    vector<d_vector> sigma_t;
    /// Energy deposition cross section.
    vector<d_vector> sigma_e;
    /// Scattering cross section.
    vector<vector<vector<d_vector> > > sigma_s;
    /// \f$\alpha\f$ parameter of the Fokker-Planck cross sections.
    d_vector alpha;
    /// Total cross section for the different level of the angular multigrid.
    vector<vector<d_vector> > sigma_t_lvl;
    /// Scattering cross section for the different level of the angular
    /// multigrid.
    vector<vector<vector<vector<d_vector> > > > sigma_s_lvl;
};
    
inline bool CROSS_SECTIONS::Sigma_e_exist() const
{
  return sigma_e_flag;
}

inline unsigned int CROSS_SECTIONS::Get_L_max() const
{
  return L_max;
}

inline unsigned int CROSS_SECTIONS::Get_n_groups() const
{
  return n_groups;
}

inline unsigned int CROSS_SECTIONS::Get_n_supergroups() const
{
  return n_supergroups;
}

inline unsigned int CROSS_SECTIONS::Get_n_grps_in_supergrp() const
{
  return n_groups/n_supergroups;
}

inline unsigned int CROSS_SECTIONS::Get_n_levels() const
{
  return n_levels;
}

inline d_vector CROSS_SECTIONS::Get_sigma_e(unsigned int i) const
{
  return sigma_e[i];
}

inline vector<d_vector> CROSS_SECTIONS::Get_sigma_t(unsigned int i) const
{
  return sigma_t_lvl[i];
}

inline vector<vector<vector<d_vector> > > CROSS_SECTIONS::Get_sigma_s(
    unsigned int i) const
{
  return sigma_s_lvl[i];
}

#endif
